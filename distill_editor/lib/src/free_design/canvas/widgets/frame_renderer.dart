import 'package:flutter/material.dart';

import '../../models/models.dart';
import '../../render/render.dart';
import '../../../../modules/canvas/canvas_state.dart';

/// Renders a single frame with its content using RenderEngine.
///
/// During viewport motion (pan/zoom), shows a low-fidelity placeholder
/// for better performance (LOD).
///
/// Uses a GlobalKey to enable node bounds tracking in frame-local coordinates.
class FrameRenderer extends StatefulWidget {
  const FrameRenderer({
    required this.frameId,
    required this.state,
    this.showPlaceholder = false,
    super.key,
  });

  final String frameId;
  final CanvasState state;
  final bool showPlaceholder;

  @override
  State<FrameRenderer> createState() => _FrameRendererState();
}

class _FrameRendererState extends State<FrameRenderer> {
  /// Key for the root widget - used by _BoundsTracker to compute frame-local coordinates.
  final _frameRootKey = GlobalKey();

  @override
  Widget build(BuildContext context) {
    // Listen to state changes so we rebuild when render cache is invalidated
    return ListenableBuilder(
      listenable: widget.state,
      builder: (context, _) {
        final frame = widget.state.document.frames[widget.frameId];
        if (frame == null) return const SizedBox.shrink();

        // Show generating placeholder if this frame is being generated by AI
        if (widget.state.isGenerating(widget.frameId)) {
          return const _GeneratingPlaceholder();
        }

        // Show placeholder during pan/zoom for performance
        if (widget.showPlaceholder) {
          return _FramePlaceholder(frame: frame);
        }

        final renderDoc = widget.state.getRenderDoc(widget.frameId);
        if (renderDoc == null) {
          return _FramePlaceholder(frame: frame);
        }

        // Wrap in KeyedSubtree so _BoundsTracker can find the frame root
        // Size is provided by parent (CanvasItem wraps us in SizedBox with preview bounds)
        // ClipRect ensures content doesn't overflow frame bounds

        // Get reflow offsets from active drag session for sibling animation
        final reflowOffsets =
            widget.state.dragSession?.dropPreview?.reflowOffsetsByExpandedId ??
                const <String, Offset>{};

        // Check if this frame is in interact mode
        final isInteractMode = widget.state.isInteractMode(widget.frameId);

        Widget content = ClipRect(
          child: KeyedSubtree(
            key: _frameRootKey,
            child: RenderEngine(
              frameRootKey: _frameRootKey,
              onBoundsChanged: (nodeId, bounds) {
                widget.state.updateNodeBounds(widget.frameId, nodeId, bounds);
              },
              reflowOffsets: reflowOffsets,
            ).build(renderDoc),
          ),
        );

        // In design mode, ignore pointer events so canvas handles selection
        // In interact mode, let the content receive events (scroll, tap, etc.)
        if (!isInteractMode) {
          content = IgnorePointer(child: content);
        }

        return content;
      },
    );
  }
}

/// Low-fidelity placeholder shown during viewport motion.
class _FramePlaceholder extends StatelessWidget {
  const _FramePlaceholder({required this.frame});

  final Frame frame;

  @override
  Widget build(BuildContext context) {
    // Size is provided by parent (CanvasItem wraps us in SizedBox with preview bounds)
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[200],
        border: Border.all(color: Colors.grey[400]!, width: 1),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Center(
        child: Text(
          frame.name,
          style: TextStyle(
            color: Colors.grey[600],
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }
}

/// Subtle placeholder shown while AI generates frame content.
class _GeneratingPlaceholder extends StatefulWidget {
  const _GeneratingPlaceholder();

  @override
  State<_GeneratingPlaceholder> createState() => _GeneratingPlaceholderState();
}

class _GeneratingPlaceholderState extends State<_GeneratingPlaceholder>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _pulseAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    )..repeat(reverse: true);

    // Gentle pulse for the spinner opacity
    _pulseAnimation = Tween<double>(begin: 0.4, end: 0.8).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Size is provided by parent (CanvasItem wraps us in SizedBox)
    return DecoratedBox(
      decoration: BoxDecoration(
        color: const Color(0xFFFCFCFC),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(
          color: const Color(0xFFE8E8E8),
          width: 1,
        ),
      ),
      child: Center(
        child: AnimatedBuilder(
          animation: _pulseAnimation,
          builder: (context, _) {
            return Opacity(
              opacity: _pulseAnimation.value,
              child: const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(
                  strokeWidth: 1.5,
                  valueColor: AlwaysStoppedAnimation(Color(0xFF9CA3AF)),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
