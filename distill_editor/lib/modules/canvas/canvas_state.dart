import 'dart:ui';

import 'package:distill_canvas/infinite_canvas.dart';
import 'package:distill_canvas/utilities.dart';
import 'package:flutter/foundation.dart';

import '../../src/free_design/canvas/drag/drag.dart';
import '../../src/free_design/free_design.dart'
    hide DragSession, DragMode, ResizeHandle, DropPreview, DropIntent;
import 'mock_frames.dart';

/// Spatial index bounds for the infinite canvas.
const Rect kCanvasBounds = Rect.fromLTWH(-50000, -50000, 100000, 100000);

/// Main state orchestrator for the canvas.
///
/// Manages:
/// - Selection state (frames and nodes)
/// - Drag sessions (move, resize, marquee)
/// - Hit testing with spatial indexing
/// - Render document caching
/// - Smart guide snapping
class CanvasState extends ChangeNotifier {
  /// The document store.
  final EditorDocumentStore _store;

  /// Token resolver for design tokens.
  final TokenResolver _tokenResolver;

  /// Public access to token resolver for property panels.
  TokenResolver get tokenResolver => _tokenResolver;

  /// Snap engine for smart guides.
  final SnapEngine _snapEngine;

  /// Scene builder for expanding instances.
  final ExpandedSceneBuilder _expander;

  /// Render compiler for creating render documents.
  late final RenderCompiler _compiler;

  /// Spatial index for O(log n) frame hit testing.
  final QuadTree<String> _frameSpatialIndex;

  /// Cached expanded scenes by frame ID.
  final Map<String, ExpandedScene> _expandedScenes = {};

  /// Cached render documents by frame ID.
  final Map<String, RenderDocument> _renderCache = {};

  /// Cached node bounds by frame ID and node ID.
  /// Bounds are in frame-local coordinates.
  final Map<String, Map<String, Rect>> _nodeBoundsCache = {};

  /// Cached outlines for AI context (keyed by "frameId:focusNodeIds").
  final Map<String, String> _outlineCache = {};

  /// Cached frame lookups (ID mappings) by frame ID.
  ///
  /// Used by DropPreviewBuilder for efficient expanded/doc ID conversions.
  final Map<String, FrameLookups> _frameLookupsCache = {};

  /// Outline compiler for AI context generation.
  final OutlineCompiler _outlineCompiler = const OutlineCompiler();

  /// Current selection.
  Set<DragTarget> _selection = {};

  /// Currently hovered target.
  DragTarget? _hovered;

  /// Active drag session (null when not dragging).
  DragSession? _dragSession;

  /// Optional canvas controller reference (for zoom menu integration).
  InfiniteCanvasController? _canvasController;

  /// Frame IDs currently being generated by AI (new frames).
  final Set<String> _generatingFrameIds = {};

  /// Frame IDs currently being updated by AI (existing frames).
  final Set<String> _updatingFrameIds = {};

  /// Frame IDs currently in interact mode (content is interactive, not selectable).
  final Set<String> _interactModeFrameIds = {};

  /// Callback to request prompt box focus.
  VoidCallback? onRequestPromptFocus;

  CanvasState({
    required EditorDocumentStore store,
    TokenResolver? tokenResolver,
    SnapEngine snapEngine = const SnapEngine(),
    ExpandedSceneBuilder expander = const ExpandedSceneBuilder(),
  }) : _store = store,
       // Use document theme for token resolution, or provided resolver
       _tokenResolver =
           tokenResolver ?? TokenResolver(store.document.theme.tokens),
       _snapEngine = snapEngine,
       _expander = expander,
       _frameSpatialIndex = QuadTree<String>(kCanvasBounds) {
    _compiler = RenderCompiler(tokens: _tokenResolver);
    _store.addListener(_onStoreChanged);
    _rebuildSpatialIndex();
  }

  /// Create a demo canvas state with mock data.
  factory CanvasState.demo() {
    final doc = _createDemoDocument();
    final store = EditorDocumentStore(document: doc);
    return CanvasState(store: store);
  }

  /// Create a demo document with sample frames and nodes.
  /// Delegates to mock_frames.dart for clean separation.
  static EditorDocument _createDemoDocument() {
    return createMinimalDemoFrames();
  }

  @override
  void dispose() {
    _store.removeListener(_onStoreChanged);
    super.dispose();
  }

  // ===========================================================================
  // Getters
  // ===========================================================================

  /// The underlying document store.
  EditorDocumentStore get store => _store;

  /// The current document.
  EditorDocument get document => _store.document;

  /// Current selection.
  Set<DragTarget> get selection => Set.unmodifiable(_selection);

  /// IDs of selected frames.
  Set<String> get selectedFrameIds =>
      _selection.whereType<FrameTarget>().map((t) => t.frameId).toSet();

  /// Selected node targets.
  Set<NodeTarget> get selectedNodes =>
      _selection.whereType<NodeTarget>().toSet();

  /// Currently hovered target.
  DragTarget? get hovered => _hovered;

  /// Whether a drag is in progress.
  bool get isDragging => _dragSession != null;

  /// The active drag session.
  DragSession? get dragSession => _dragSession;

  /// The canvas controller (for zoom menu integration).
  InfiniteCanvasController? get canvasController => _canvasController;

  /// Frame IDs currently being generated by AI.
  Set<String> get generatingFrameIds => Set.unmodifiable(_generatingFrameIds);

  /// Check if a specific frame is being generated.
  bool isGenerating(String frameId) => _generatingFrameIds.contains(frameId);

  /// Mark a frame as generating (placeholder state).
  void startGenerating(String frameId) {
    _generatingFrameIds.add(frameId);
    notifyListeners();
  }

  /// Mark a frame as done generating.
  void finishGenerating(String frameId) {
    _generatingFrameIds.remove(frameId);
    notifyListeners();
  }

  /// Frame IDs currently being updated by AI.
  Set<String> get updatingFrameIds => Set.unmodifiable(_updatingFrameIds);

  /// Check if a specific frame is being updated by AI.
  bool isUpdating(String frameId) => _updatingFrameIds.contains(frameId);

  /// Mark a frame as being updated by AI (animated border state).
  void startUpdating(String frameId) {
    _updatingFrameIds.add(frameId);
    notifyListeners();
  }

  /// Mark a frame as done updating.
  void finishUpdating(String frameId) {
    _updatingFrameIds.remove(frameId);
    notifyListeners();
  }

  // ===========================================================================
  // Interact Mode
  // ===========================================================================

  /// Check if a specific frame is in interact mode.
  ///
  /// In interact mode, frame content is interactive (scrollable, tappable)
  /// but nodes cannot be selected.
  bool isInteractMode(String frameId) =>
      _interactModeFrameIds.contains(frameId);

  /// Toggle interact mode for a frame.
  void toggleInteractMode(String frameId) {
    if (_interactModeFrameIds.contains(frameId)) {
      _interactModeFrameIds.remove(frameId);
    } else {
      _interactModeFrameIds.add(frameId);
    }
    notifyListeners();
  }

  /// Active snap guides to render.
  List<SnapGuide> get activeGuides => _dragSession?.activeGuides ?? const [];

  // ===========================================================================
  // Node Bounds
  // ===========================================================================

  /// Update the bounds for a node within a frame.
  ///
  /// Called by the RenderEngine's bounds tracker after layout.
  /// Bounds should be in frame-local coordinates.
  void updateNodeBounds(String frameId, String nodeId, Rect bounds) {
    _nodeBoundsCache.putIfAbsent(frameId, () => {});
    final frameBounds = _nodeBoundsCache[frameId]!;

    // Only update if changed to avoid unnecessary rebuilds
    if (frameBounds[nodeId] != bounds) {
      frameBounds[nodeId] = bounds;
      // Don't notify listeners here - this is called during build
    }
  }

  /// Get the cached bounds for a node in frame-local coordinates.
  ///
  /// This only returns measured bounds from the cache. For bounds with
  /// fallback chain (compiled → props), use [getNodeBoundsResolved].
  Rect? getNodeBounds(String frameId, String nodeId) {
    return _nodeBoundsCache[frameId]?[nodeId];
  }

  /// Get bounds for a node with full fallback chain.
  ///
  /// Priority order:
  /// 1. Measured bounds (from BoundsTracker post-frame callback)
  /// 2. Compiled bounds (from RenderCompiler for absolute+fixed nodes)
  /// 3. Props fallback (safety measure for absolute+fixed nodes)
  ///
  /// Use this instead of [getNodeBounds] when you need bounds that may not
  /// have been measured yet (e.g., during drag preview, insertion indicator).
  Rect? getNodeBoundsResolved(String frameId, String nodeId) {
    return _getNodeBoundsForFrame(frameId, nodeId);
  }

  /// Clear cached bounds for a frame.
  void _clearNodeBounds(String frameId) {
    _nodeBoundsCache.remove(frameId);
  }

  // ===========================================================================
  // Selection Methods
  // ===========================================================================

  /// Select a target.
  ///
  /// If [addToSelection] is false, replaces the current selection.
  void select(DragTarget target, {bool addToSelection = false}) {
    if (addToSelection) {
      _selection = {..._selection, target};
    } else {
      _selection = {target};
    }
    notifyListeners();
  }

  /// Select a frame by ID.
  void selectFrame(String frameId, {bool addToSelection = false}) {
    select(FrameTarget(frameId), addToSelection: addToSelection);
  }

  /// Select a node by its expanded ID.
  void selectNode(
    String frameId,
    String expandedId, {
    bool addToSelection = false,
  }) {
    final scene = getExpandedScene(frameId);
    final patchTarget = scene?.patchTarget[expandedId];

    select(
      NodeTarget(
        frameId: frameId,
        expandedId: expandedId,
        patchTarget: patchTarget,
      ),
      addToSelection: addToSelection,
    );
  }

  /// Deselect a specific target.
  void deselect(DragTarget target) {
    _selection = _selection.where((t) => t != target).toSet();
    notifyListeners();
  }

  /// Clear all selections.
  void deselectAll() {
    if (_selection.isEmpty) return;
    _selection = {};
    notifyListeners();
  }

  /// Set the canvas controller reference (for zoom menu integration).
  void setCanvasController(InfiniteCanvasController controller) {
    _canvasController = controller;
    notifyListeners();
  }

  /// Clear the canvas controller reference.
  void clearCanvasController() {
    _canvasController = null;
  }

  /// Request the prompt box to be focused.
  void requestPromptFocus() {
    onRequestPromptFocus?.call();
  }

  /// Select all frames whose bounds intersect the given world rect.
  ///
  /// Replaces the current selection.
  void selectFramesInRect(Rect worldRect) {
    final frameIds = _frameSpatialIndex.query(worldRect).toSet();
    _selection = frameIds.map((id) => FrameTarget(id)).toSet();
    notifyListeners();
  }

  /// Set the hovered target.
  void setHovered(DragTarget? target) {
    if (_hovered == target) return;
    _hovered = target;
    notifyListeners();
  }

  // ===========================================================================
  // Cache Access
  // ===========================================================================

  /// Get the expanded scene for a frame.
  ///
  /// Returns null if the frame doesn't exist.
  ExpandedScene? getExpandedScene(String frameId) {
    // Check cache first
    var scene = _expandedScenes[frameId];
    if (scene != null) return scene;

    // Build and cache
    scene = _expander.build(frameId, document);
    if (scene != null) {
      _expandedScenes[frameId] = scene;
    }
    return scene;
  }

  /// Get the render document for a frame.
  ///
  /// Returns null if the frame doesn't exist.
  RenderDocument? getRenderDoc(String frameId) {
    // Check cache first
    var renderDoc = _renderCache[frameId];
    if (renderDoc != null) {
      return renderDoc;
    }

    // Get expanded scene
    final scene = getExpandedScene(frameId);
    if (scene == null) {
      return null;
    }

    // Compile and cache
    renderDoc = _compiler.compile(scene);
    _renderCache[frameId] = renderDoc;
    return renderDoc;
  }

  /// Get pre-computed ID lookups for a frame.
  ///
  /// Builds and caches lookups from ExpandedScene and RenderDocument.
  /// Returns null if scene or render doc not available.
  ///
  /// Used by [DropPreviewBuilder] for efficient expanded/doc ID conversions
  /// during drag operations.
  FrameLookups? getFrameLookups(String frameId) {
    var lookups = _frameLookupsCache[frameId];
    if (lookups != null) return lookups;

    final scene = getExpandedScene(frameId);
    final renderDoc = getRenderDoc(frameId);
    if (scene == null || renderDoc == null) return null;

    lookups = FrameLookups.build(scene: scene, renderDoc: renderDoc);
    _frameLookupsCache[frameId] = lookups;
    return lookups;
  }

  /// Get the outline for AI context.
  ///
  /// Returns a compact tree-structured view of the frame optimized for
  /// LLM context. Results are cached and invalidated when the document changes.
  ///
  /// [frameId] - The frame to generate outline for.
  /// [focusNodeIds] - Nodes being edited (marked with ← EDITING).
  /// [maxDepth] - Maximum tree depth to expand (default 2).
  String getOutline(
    String frameId,
    List<String> focusNodeIds, {
    int maxDepth = 2,
  }) {
    final cacheKey = '$frameId:${focusNodeIds.join(",")}';

    var outline = _outlineCache[cacheKey];
    if (outline != null) {
      return outline;
    }

    outline = _outlineCompiler.compile(
      _store.document,
      focusNodeIds: focusNodeIds,
      frameId: frameId,
      maxDepth: maxDepth,
    );

    _outlineCache[cacheKey] = outline;
    return outline;
  }

  // ===========================================================================
  // Hit Testing
  // ===========================================================================

  /// Hit test for a frame at the given world position.
  ///
  /// Returns the topmost frame containing the point, or null if none.
  FrameTarget? hitTestFrame(Offset worldPos) {
    final candidates = _frameSpatialIndex.hitTest(worldPos).toList();
    if (candidates.isEmpty) return null;

    // Return first candidate (QuadTree returns in insertion order)
    // In practice, you might want to sort by z-index
    // For now, return the last one (most recently added = on top)
    return FrameTarget(candidates.last);
  }

  /// Hit test for a node within a frame at the given world position.
  ///
  /// Converts world coordinates to frame-local coordinates before testing.
  /// Returns the smallest node by area containing the point.
  ///
  /// Note: Root node is now included in hit testing. Frames are selected
  /// via their labels, not by clicking inside frame bounds.
  NodeTarget? hitTestNode(Offset worldPos, String frameId) {
    final frame = document.frames[frameId];
    if (frame == null) return null;

    final scene = getExpandedScene(frameId);
    final renderDoc = getRenderDoc(frameId);
    if (scene == null || renderDoc == null) return null;

    // Get frame position - use preview bounds during drag if applicable
    final framePos = _getFramePosition(frameId);

    // Convert world position to frame-local
    final localPos = worldPos - framePos;

    // Find all nodes containing the point (including root node)
    final hits = <(String, double)>[]; // (expandedId, area)

    for (final entry in renderDoc.nodes.entries) {
      final nodeId = entry.key;

      // Get bounds (from cache or props)
      final bounds = _getNodeBoundsForFrame(frameId, nodeId);
      if (bounds != null && bounds.contains(localPos)) {
        hits.add((nodeId, bounds.width * bounds.height));
      }
    }

    if (hits.isEmpty) return null;

    // Sort by area (smallest first) - smallest node is most specific
    hits.sort((a, b) => a.$2.compareTo(b.$2));
    final hitId = hits.first.$1;

    return NodeTarget(
      frameId: frameId,
      expandedId: hitId,
      patchTarget: scene.patchTarget[hitId],
    );
  }

  /// Hit test for resize handles on the current selection.
  ///
  /// [viewPos] is in view/screen coordinates.
  /// [worldToView] converts world coordinates to view coordinates.
  /// [hitRadius] is the touch radius in view pixels.
  ResizeHandle? hitTestResizeHandle(
    Offset viewPos,
    Offset Function(Offset world) worldToView,
    double hitRadius,
  ) {
    if (_selection.length != 1) return null;

    final target = _selection.first;
    final bounds = _getTargetBounds(target);
    if (bounds == null) return null;

    // Convert handle positions to view space
    final handlePositions = <ResizeHandle, Offset>{
      ResizeHandle.topLeft: worldToView(bounds.topLeft),
      ResizeHandle.topCenter: worldToView(bounds.topCenter),
      ResizeHandle.topRight: worldToView(bounds.topRight),
      ResizeHandle.middleLeft: worldToView(bounds.centerLeft),
      ResizeHandle.middleRight: worldToView(bounds.centerRight),
      ResizeHandle.bottomLeft: worldToView(bounds.bottomLeft),
      ResizeHandle.bottomCenter: worldToView(bounds.bottomCenter),
      ResizeHandle.bottomRight: worldToView(bounds.bottomRight),
    };

    // Find closest handle within radius
    for (final entry in handlePositions.entries) {
      final distance = (entry.value - viewPos).distance;
      if (distance <= hitRadius) {
        return entry.key;
      }
    }

    return null;
  }

  /// Hit test to find container node under cursor (world coordinates).
  ///
  /// Returns the deepest container that contains the point, or the frame's
  /// root node ID if no specific container is hit.
  ///
  /// Returns null if the frame doesn't exist or has no scene.
  /// Hit test to find the deepest container at [worldPos].
  ///
  /// Returns a [ContainerHit] with both the document node ID (for patching)
  /// and the expanded ID (for bounds lookup). This ensures the indicator
  /// draws at the correct location when multiple expanded nodes share
  /// the same document ID (e.g., in component instances).
  ///
  /// [excludeExpandedIds] - Optional set of expanded IDs to skip during hit testing.
  /// Use this to exclude dragged nodes so hit testing can "see through" them
  /// to find the actual parent container during reordering operations.
  /// Note: Uses expanded IDs (not doc IDs) for proper instance handling (INV-1).
  ContainerHit? hitTestContainer(
    String frameId,
    Offset worldPos, {
    Set<String>? excludeExpandedIds,
  }) {
    final frame = document.frames[frameId];
    if (frame == null) return null;

    // Convert to frame-local
    final framePos = _getFramePosition(frameId);
    final frameLocalPos = worldPos - framePos;

    // Get all nodes in frame
    final scene = getExpandedScene(frameId);
    if (scene == null) return null;

    final renderDoc = getRenderDoc(frameId);
    if (renderDoc == null) return null;

    // Iterate in REVERSE order (topmost/deepest containers first)
    // Return on first hit for deterministic behavior
    final keys = renderDoc.nodes.keys.toList(growable: false);
    for (var i = keys.length - 1; i >= 0; i--) {
      final expandedId = keys[i];
      final node = renderDoc.nodes[expandedId];
      if (node == null) continue;

      // Skip non-containers (only box, row, column can accept children)
      // Text, image, icon, spacer cannot have children
      final isContainer =
          node.type == RenderNodeType.box ||
          node.type == RenderNodeType.row ||
          node.type == RenderNodeType.column;
      if (!isContainer) continue;

      // Get the document node to check if it can accept children
      final patchTargetId = scene.patchTarget[expandedId];
      if (patchTargetId == null) continue; // Inside instance, skip

      // Skip excluded nodes (e.g., dragged nodes during reordering)
      // INV-1: Use expandedId for exclusion, not docId
      if (excludeExpandedIds != null && excludeExpandedIds.contains(expandedId)) {
        continue;
      }

      final docNode = document.nodes[patchTargetId];
      if (docNode == null) continue;

      // Get bounds
      final bounds = _getNodeBoundsForFrame(frameId, expandedId);
      if (bounds == null) continue;

      // EARLY RETURN on first hit (topmost wins)
      // Return both IDs so indicator can use the correct expandedId for bounds
      if (bounds.contains(frameLocalPos)) {
        return ContainerHit(expandedId: expandedId, docId: patchTargetId);
      }
    }

    // Fallback to frame root if no container hit
    // Find the expandedId for the root node
    final rootExpandedId = scene.patchTarget.entries
        .firstWhere(
          (e) => e.value == frame.rootNodeId,
          orElse: () => MapEntry(frame.rootNodeId, frame.rootNodeId),
        )
        .key;
    return ContainerHit(expandedId: rootExpandedId, docId: frame.rootNodeId);
  }

  /// Validate if a node can be reparented to target parent.
  ///
  /// Returns false if:
  /// - Would create circular reference (parent into its own child)
  /// - Target node doesn't exist
  /// - Target is inside an instance (can't modify instance internals)
  bool canReparent(String nodeId, String targetParentId) {
    // Prevent circular reparenting (moving nodeId into one of its descendants)
    // Check if nodeId is an ancestor of targetParentId
    if (_isAncestor(nodeId, targetParentId)) {
      return false;
    }

    // Also prevent reparenting to self
    if (nodeId == targetParentId) {
      return false;
    }

    // Check if target exists
    final targetNode = document.nodes[targetParentId];
    if (targetNode == null) return false;

    // Check if target can accept children (must be a container)
    if (targetNode.type != NodeType.container) {
      return false;
    }

    return true;
  }

  /// Check if potentialAncestor is an ancestor of nodeId.
  bool _isAncestor(String potentialAncestor, String nodeId) {
    final parentIndex = _store.parentIndex;

    String? current = nodeId;
    while (current != null) {
      if (current == potentialAncestor) return true;
      current = parentIndex[current];
    }

    return false;
  }

  /// Get the parent of a node, or null if it's a root node.
  String? getParent(String nodeId) => _store.getParent(nodeId);

  /// Convert frame-local coordinates to parent-local coordinates.
  ///
  /// Returns the position relative to the parent container's top-left corner.
  Offset frameLocalToParentLocal(
    Offset frameLocal,
    String parentId,
    String frameId,
  ) {
    final scene = getExpandedScene(frameId);
    if (scene == null) return frameLocal;

    // Find the expanded ID for this parent
    String? parentExpandedId;
    for (final entry in scene.patchTarget.entries) {
      if (entry.value == parentId) {
        parentExpandedId = entry.key;
        break;
      }
    }

    if (parentExpandedId == null) return frameLocal;

    final parentBounds = _getNodeBoundsForFrame(frameId, parentExpandedId);
    if (parentBounds == null) return frameLocal;

    return frameLocal - parentBounds.topLeft;
  }

  /// Get all child bounds for a parent (for insertion calculation).
  ///
  /// Returns a map of expanded ID to bounds for all children of the parent.
  Map<String, Rect?> getChildBoundsForParent(String frameId, String parentId) {
    final parent = document.nodes[parentId];
    if (parent == null) return {};

    final scene = getExpandedScene(frameId);
    if (scene == null) return {};

    final result = <String, Rect?>{};

    // Map child IDs to their expanded IDs and get bounds
    for (final childId in parent.childIds) {
      // Find expanded ID for this child
      for (final entry in scene.patchTarget.entries) {
        if (entry.value == childId) {
          final expandedId = entry.key;
          result[childId] = _getNodeBoundsForFrame(frameId, expandedId);
          break;
        }
      }
    }

    return result;
  }

  /// Calculate insertion index for cursor position within parent container.
  ///
  /// Returns index where node should be inserted (0 = before first child).
  /// For auto-layout containers, compares cursor position to child centers.
  /// For non-auto-layout containers, appends to end.
  ///
  /// [draggedNodeIds] - Optional set of node IDs being dragged. These are
  /// excluded from the calculation to avoid off-by-one errors when reordering.
  /// [childrenOverride] - Optional pre-computed children list. If provided,
  /// takes precedence over draggedNodeIds filtering (for consistency).
  int calculateInsertionIndex(
    String frameId,
    String parentId,
    Offset worldCursorPos, {
    Set<String>? draggedNodeIds,
    List<String>? childrenOverride,
  }) {
    final parent = document.nodes[parentId];
    if (parent == null) return 0;

    // If no auto-layout, append to end
    if (parent.layout.autoLayout == null) {
      final children = childrenOverride ?? parent.childIds;
      return children.length;
    }

    final frame = document.frames[frameId];
    if (frame == null) return 0;

    // Convert world → frame-local → parent-local
    final framePos = _getFramePosition(frameId);
    final cursorFrameLocal = worldCursorPos - framePos;
    final cursorParentLocal = frameLocalToParentLocal(
      cursorFrameLocal,
      parentId,
      frameId,
    );

    final direction = parent.layout.autoLayout!.direction;
    final childBounds = getChildBoundsForParent(frameId, parentId);

    // Use provided children list, or filter out dragged nodes
    final childrenToCheck = childrenOverride ??
        (draggedNodeIds != null
            ? parent.childIds.where((id) => !draggedNodeIds.contains(id)).toList()
            : parent.childIds);

    // Find insertion point by comparing cursor to child centers
    for (int i = 0; i < childrenToCheck.length; i++) {
      final childId = childrenToCheck[i];
      final bounds = childBounds[childId];
      if (bounds == null) continue; // Skip unmeasured children

      // Use center as threshold
      final threshold = direction == LayoutDirection.horizontal
          ? bounds.center.dx
          : bounds.center.dy;

      final cursorValue = direction == LayoutDirection.horizontal
          ? cursorParentLocal.dx
          : cursorParentLocal.dy;

      if (cursorValue < threshold) {
        return i; // Insert before this child
      }
    }

    return childrenToCheck.length; // Insert at end
  }

  /// Calculate reflow offsets for siblings during drag (for animation preview).
  ///
  /// Returns a map of expandedId → offset to apply during drag.
  /// This creates the Figma-style animation where siblings shift to make room.
  ///
  /// [spaceNeeded] - Total space the dragged bundle needs (main-axis size + gap).
  /// [childrenOverride] - Pre-computed children list (excludes dragged nodes).
  Map<String, Offset> calculateReflowOffsets(
    String frameId,
    String parentId,
    int insertionIndex,
    double spaceNeeded, {
    List<String>? childrenOverride,
  }) {
    final parent = document.nodes[parentId];
    if (parent == null || parent.layout.autoLayout == null) {
      return const {};
    }

    final direction = parent.layout.autoLayout!.direction;
    final children = childrenOverride ?? parent.childIds;

    // Build docId → expandedId mapping for render engine lookup
    final scene = getExpandedScene(frameId);
    if (scene == null) return const {};

    final docToExpanded = <String, String>{};
    for (final entry in scene.patchTarget.entries) {
      if (entry.value != null) {
        docToExpanded[entry.value!] = entry.key; // docId → expandedId
      }
    }

    final offsets = <String, Offset>{};

    // Shift all siblings at or after the insertion index
    for (var i = insertionIndex; i < children.length; i++) {
      final childDocId = children[i];
      final expandedId = docToExpanded[childDocId];
      if (expandedId == null) continue;

      // Apply offset based on layout direction
      if (direction == LayoutDirection.horizontal) {
        offsets[expandedId] = Offset(spaceNeeded, 0);
      } else {
        offsets[expandedId] = Offset(0, spaceNeeded);
      }
    }

    return offsets;
  }

  // ===========================================================================
  // Drag Operations
  // ===========================================================================

  /// Start a move drag on the current selection.
  void startDrag() {
    if (_selection.isEmpty) return;

    final startPositions = <DragTarget, Offset>{};
    final startSizes = <DragTarget, Size>{};
    final originalParents = <String, String>{};

    for (final target in _selection) {
      final bounds = _getTargetBounds(target);
      if (bounds != null) {
        startPositions[target] = bounds.topLeft;
        startSizes[target] = bounds.size;
      }

      // Track original parent for nodes (for reparenting detection)
      if (target is NodeTarget && target.patchTarget != null) {
        final nodeId = target.patchTarget!;
        final parentId = _store.parentIndex[nodeId];
        if (parentId != null) {
          originalParents[nodeId] = parentId;
        }
      }
    }

    // INV-5: Capture frameId at drag start for node drags
    String? lockedFrameId;
    final nodeTargets = _selection.whereType<NodeTarget>().toList();
    if (nodeTargets.isNotEmpty) {
      lockedFrameId = nodeTargets.first.frameId;
    }

    // Capture origin stickiness data (expanded-first per INV-1)
    // This prevents immediately targeting parent-of-parent when starting drag
    String? originParentExpandedId;
    Rect? originParentContentWorldRect;

    if (nodeTargets.isNotEmpty && lockedFrameId != null) {
      final lookups = getFrameLookups(lockedFrameId);

      if (lookups != null) {
        // Get the first dragged node's expanded ID
        final primaryDraggedExpandedId = nodeTargets.first.expandedId;

        // Derive origin parent from EXPANDED tree, not doc tree (INV-1 compliant)
        // This ensures we use the correct instance when a parent appears multiple times
        originParentExpandedId = lookups.expandedParent[primaryDraggedExpandedId];

        // In v1 multi-select, verify all dragged nodes share the same expanded parent
        // This is the expanded-tree equivalent of INV-7 (doc-parent constraint)
        if (nodeTargets.length > 1) {
          for (final target in nodeTargets.skip(1)) {
            final parent = lookups.expandedParent[target.expandedId];
            if (parent != originParentExpandedId) {
              // Different expanded parents - can't use stickiness
              // (This shouldn't happen with INV-7, but be defensive)
              originParentExpandedId = null;
              break;
            }
          }
        }

        // Compute content rect in WORLD coordinates
        if (originParentExpandedId != null) {
          // IMPORTANT: getNodeBoundsResolved returns FRAME-LOCAL bounds
          // We must shift by frame position to get world coordinates
          final frameLocalBounds =
              getNodeBoundsResolved(lockedFrameId, originParentExpandedId);
          if (frameLocalBounds != null) {
            final framePos =
                document.frames[lockedFrameId]?.canvas.position ?? Offset.zero;
            final worldBounds = frameLocalBounds.shift(framePos);

            // Get padding from doc node to compute content box
            final originDocId = lookups.expandedToDoc[originParentExpandedId];
            if (originDocId != null) {
              final docNode = document.nodes[originDocId];
              final autoLayout = docNode?.layout.autoLayout;
              if (autoLayout != null) {
                final padding = autoLayout.padding;
                originParentContentWorldRect = Rect.fromLTRB(
                  worldBounds.left + (padding.left.toDouble()),
                  worldBounds.top + (padding.top.toDouble()),
                  worldBounds.right - (padding.right.toDouble()),
                  worldBounds.bottom - (padding.bottom.toDouble()),
                );
              } else {
                // Not auto-layout - stickiness won't help (will climb anyway)
                originParentExpandedId = null;
              }
            }
          }
        }
      }
    }

    _dragSession = DragSession.move(
      targets: _selection,
      startPositions: startPositions,
      startSizes: startSizes,
      originalParents: originalParents,
      lockedFrameId: lockedFrameId,
      originParentExpandedId: originParentExpandedId,
      originParentContentWorldRect: originParentContentWorldRect,
    );
    notifyListeners();
  }

  /// Update the current drag with a delta.
  ///
  /// [worldDelta] is the movement in world coordinates.
  /// [gridSize] enables grid snapping if provided.
  /// [useSmartGuides] enables object-to-object snapping.
  /// [zoom] is the current viewport zoom level for snap distance calculation.
  void updateDrag(
    Offset worldDelta, {
    double? gridSize,
    bool useSmartGuides = true,
    double zoom = 1.0,
  }) {
    final session = _dragSession;
    if (session == null || session.mode != DragMode.move) return;

    // Keep raw user accumulator (don't replace with snap position)
    final rawAccumulator = session.accumulator + worldDelta;

    // Reset snap offset - will be recalculated if snapping occurs
    var snapOffset = Offset.zero;
    var guides = <SnapGuide>[];

    // Smart guide snapping
    if (useSmartGuides && session.targets.isNotEmpty) {
      // IMPORTANT: Use original bounds (from document) not preview bounds.
      // The preview bounds already include effectiveOffset, so shifting by
      // rawAccumulator again would double-count the movement.
      final originalBounds = _getSelectionBounds(useOriginalBounds: true);
      if (originalBounds != null) {
        final otherBounds = _getOtherFrameBounds(exclude: selectedFrameIds);

        // Calculate snap based on raw position (original + rawAccumulator)
        final proposedBounds = originalBounds.shift(rawAccumulator);
        final result = _snapEngine.calculate(
          movingBounds: proposedBounds,
          otherBounds: otherBounds,
          zoom: zoom,
        );

        if (result.didSnap) {
          // Calculate snap offset (difference between raw and snapped)
          // This preserves user's raw input while adding snap adjustment
          snapOffset = result.snappedBounds.topLeft - proposedBounds.topLeft;
          guides = result.guides;
        }
      }
    }

    // Store raw accumulator and snap offset separately
    session.accumulator = rawAccumulator;
    session.snapOffset = snapOffset;
    session.activeGuides = guides;

    // Grid snapping (only if no smart guide snap) - applies to raw accumulator
    if (gridSize != null && guides.isEmpty) {
      session.accumulator = Offset(
        (rawAccumulator.dx / gridSize).round() * gridSize,
        (rawAccumulator.dy / gridSize).round() * gridSize,
      );
      session.snapOffset = Offset.zero;
    }

    notifyListeners();
  }

  /// End the current drag and commit changes.
  void endDrag() {
    final session = _dragSession;
    if (session == null) return;

    final patches = <PatchOp>[];

    if (session.mode == DragMode.move) {
      final dropPreview = session.dropPreview;

      // Handle node structural changes via DropCommitPlan
      if (dropPreview != null && dropPreview.isValid) {
        final plan = DropCommitPlan.fromPreview(
          dropPreview,
          session.originalParents,
        );

        if (plan.canCommit) {
          patches.addAll(generateDropPatches(plan));
        }
      }

      // Handle frame moves separately (frames don't have drop preview)
      for (final target in session.targets) {
        if (target is FrameTarget) {
          final startPos = session.startPositions[target];
          if (startPos != null) {
            final newPos = startPos + session.effectiveOffset;
            patches.add(
              SetFrameProp(
                frameId: target.frameId,
                path: '/canvas/position',
                value: {'x': newPos.dx, 'y': newPos.dy},
              ),
            );
          }
        }
      }
    } else {
      // Resize, marquee, etc. - use existing logic
      patches.addAll(session.generatePatches());
    }

    if (patches.isNotEmpty) {
      _store.applyPatches(patches);
    }

    _dragSession = null;
    notifyListeners();
  }

  /// Cancel the current drag without committing.
  void cancelDrag() {
    if (_dragSession == null) return;
    _dragSession = null;
    notifyListeners();
  }

  /// Start a resize drag on the current selection.
  void startResize(ResizeHandle handle) {
    if (_selection.length != 1) return;

    final target = _selection.first;

    // Disable resizing for nodes - only allow frame resizing
    if (target is NodeTarget) return;

    final bounds = _getTargetBounds(target);
    if (bounds == null) return;

    _dragSession = DragSession.resize(
      target: target,
      handle: handle,
      startPosition: bounds.topLeft,
      startSize: bounds.size,
    );
    notifyListeners();
  }

  /// Update the current resize with a delta.
  ///
  /// [worldDelta] is the movement in world coordinates.
  /// [gridSize] enables grid snapping if provided.
  /// [useSmartGuides] enables edge-to-edge snapping during resize.
  /// [zoom] is the current viewport zoom level for snap distance calculation.
  void updateResize(
    Offset worldDelta, {
    double? gridSize,
    bool useSmartGuides = true,
    double zoom = 1.0,
  }) {
    final session = _dragSession;
    if (session == null || session.mode != DragMode.resize) return;

    var newAccumulator = session.accumulator + worldDelta;

    // Smart guide snapping for resize
    if (useSmartGuides &&
        session.handle != null &&
        session.targets.isNotEmpty) {
      final target = session.targets.first;
      final startPos = session.startPositions[target];
      final startSize = session.startSizes[target];

      if (startPos != null && startSize != null) {
        final startBounds = Rect.fromLTWH(
          startPos.dx,
          startPos.dy,
          startSize.width,
          startSize.height,
        );

        final otherBounds = _getOtherFrameBounds(exclude: selectedFrameIds);

        final result = _snapEngine.calculateResize(
          currentBounds: startBounds,
          activeEdges: session.handle!.activeEdges,
          delta: newAccumulator,
          otherBounds: otherBounds,
          zoom: zoom,
        );

        if (result.didSnap) {
          // Calculate adjusted accumulator from snapped bounds
          newAccumulator = _accumulatorFromSnappedResize(
            startBounds,
            result.snappedBounds,
            session.handle!,
          );
          session.activeGuides = result.guides;
        } else {
          session.activeGuides = const [];
        }
      }
    }

    // Grid snapping (fallback when no smart guide snap)
    if (gridSize != null && session.activeGuides.isEmpty) {
      newAccumulator = Offset(
        (newAccumulator.dx / gridSize).round() * gridSize,
        (newAccumulator.dy / gridSize).round() * gridSize,
      );
    }

    session.accumulator = newAccumulator;
    notifyListeners();
  }

  /// Calculate accumulator offset from snapped resize bounds.
  Offset _accumulatorFromSnappedResize(
    Rect startBounds,
    Rect snappedBounds,
    ResizeHandle handle,
  ) {
    double dx = 0;
    double dy = 0;

    // Calculate delta based on which edges were affected
    if (handle.isLeft) {
      dx = snappedBounds.left - startBounds.left;
    } else if (handle.isRight) {
      dx = snappedBounds.right - startBounds.right;
    }

    if (handle.isTop) {
      dy = snappedBounds.top - startBounds.top;
    } else if (handle.isBottom) {
      dy = snappedBounds.bottom - startBounds.bottom;
    }

    return Offset(dx, dy);
  }

  // ===========================================================================
  // Marquee Operations
  // ===========================================================================

  /// Start a marquee selection drag.
  void startMarquee(Offset worldPos) {
    _dragSession = DragSession.marquee(startPosition: worldPos);
    notifyListeners();
  }

  /// Update marquee with current world position.
  void updateMarquee(Offset worldPos) {
    final session = _dragSession;
    if (session == null || session.mode != DragMode.marquee) return;

    session.accumulator = worldPos;
    notifyListeners();
  }

  /// End marquee and select frames in rect.
  void endMarquee() {
    final session = _dragSession;
    if (session == null || session.mode != DragMode.marquee) return;

    final rect = session.getMarqueeRect();
    if (rect != null && rect.width > 5 && rect.height > 5) {
      // Only select if marquee is non-trivial (avoid accidental click-selects)
      selectFramesInRect(rect);
    }

    _dragSession = null;
    notifyListeners();
  }

  // ===========================================================================
  // Internals
  // ===========================================================================

  /// Handle store changes.
  void _onStoreChanged() {
    final changes = _store.pendingChanges;

    // Invalidate affected caches
    if (changes.frameDirty.isNotEmpty) {
      _rebuildSpatialIndex();
      for (final frameId in changes.frameDirty) {
        _expandedScenes.remove(frameId);
        _renderCache.remove(frameId);
        _frameLookupsCache.remove(frameId);
        // Note: We don't clear node bounds here because frame position/size
        // changes don't affect node bounds (which are frame-local).
        // Node bounds only need to be cleared when the node structure changes
        // (handled in compilationDirty below).
      }
    }

    if (changes.compilationDirty.isNotEmpty) {
      // Find which frames contain these nodes and invalidate.
      // We clear the entire frame's expanded scene and render cache rather than
      // trying to selectively invalidate, because:
      // 1. Document node IDs don't map directly to expanded IDs (instances namespace them)
      // 2. Component changes affect all instances using that component
      // 3. Full frame recompile is still fast enough for v1
      final affectedFrames = <String>{};
      for (final nodeId in changes.compilationDirty) {
        final frameId = _store.getFrameForNode(nodeId);
        if (frameId != null) {
          affectedFrames.add(frameId);
        }
      }

      for (final frameId in affectedFrames) {
        _expandedScenes.remove(frameId);
        _renderCache.remove(frameId);
        _frameLookupsCache.remove(frameId);
        _clearNodeBounds(frameId);
      }

      // CRITICAL: Also invalidate the RenderCompiler's internal cache
      // Otherwise it will serve stale compiled nodes with old property values
      _compiler.invalidateAll();
    }

    // Handle geometry changes (position/size edits) - PHASE 1 FIX
    if (changes.geometryDirty.isNotEmpty) {
      final affectedFrames = <String>{};
      for (final nodeId in changes.geometryDirty) {
        final frameId = _store.getFrameForNode(nodeId);
        if (frameId != null) {
          affectedFrames.add(frameId);
        }
      }

      // Clear render cache AND bounds for affected frames
      // Render nodes hold old computed bounds/props that must be invalidated
      for (final frameId in affectedFrames) {
        _renderCache.remove(frameId);
        _frameLookupsCache.remove(frameId);
        _clearNodeBounds(frameId);
      }
    }

    // Invalidate outline cache on any change
    // Outlines are derived from document state and must reflect current structure
    _outlineCache.clear();

    _store.clearChanges();
    notifyListeners();
  }

  /// Rebuild the spatial index for frames.
  void _rebuildSpatialIndex() {
    _frameSpatialIndex.clear();
    for (final frame in document.frames.values) {
      final bounds = Rect.fromLTWH(
        frame.canvas.position.dx,
        frame.canvas.position.dy,
        frame.canvas.size.width,
        frame.canvas.size.height,
      );
      _frameSpatialIndex.insert(frame.id, bounds);
    }
  }

  /// Get the current position of a frame, accounting for active drag sessions.
  ///
  /// During a drag/resize, returns the preview position. Otherwise returns
  /// the committed position from the document.
  Offset _getFramePosition(String frameId) {
    final frame = document.frames[frameId];
    if (frame == null) return Offset.zero;

    // Check if this frame is being dragged
    final session = _dragSession;
    if (session != null) {
      final target = FrameTarget(frameId);
      final previewBounds = session.getCurrentBounds(target);
      if (previewBounds != null) {
        return previewBounds.topLeft;
      }
    }

    return frame.canvas.position;
  }

  /// Get bounds for a drag target in world coordinates.
  ///
  /// Uses preview bounds during drag sessions.
  Rect? _getTargetBounds(DragTarget target) {
    // Check for preview bounds during drag
    final session = _dragSession;
    if (session != null) {
      final previewBounds = session.getCurrentBounds(target);
      if (previewBounds != null) {
        return previewBounds;
      }
    }

    switch (target) {
      case FrameTarget(:final frameId):
        final frame = document.frames[frameId];
        if (frame == null) return null;
        return Rect.fromLTWH(
          frame.canvas.position.dx,
          frame.canvas.position.dy,
          frame.canvas.size.width,
          frame.canvas.size.height,
        );

      case NodeTarget(:final frameId, :final expandedId):
        final frame = document.frames[frameId];
        if (frame == null) return null;

        final localBounds = _getNodeBoundsForFrame(frameId, expandedId);
        if (localBounds == null) return null;

        // Convert to world coordinates using current frame position
        return localBounds.shift(_getFramePosition(frameId));
    }
  }

  /// Get bounds for a render node in frame-local coordinates.
  ///
  /// First checks the cached bounds from the RenderEngine's bounds tracker.
  /// Falls back to explicit position/size from node props for absolute-positioned nodes.
  /// Get frame-local bounds for a node.
  ///
  /// Priority order:
  /// 1. Measured bounds (from BoundsTracker post-frame callback)
  /// 2. Compiled bounds (from RenderCompiler for absolute+fixed nodes)
  /// 3. Props fallback (safety measure)
  /// 4. Null (bounds not yet available)
  Rect? _getNodeBoundsForFrame(String frameId, String nodeId) {
    // 1. Check measured bounds cache first (most accurate)
    final cached = _nodeBoundsCache[frameId]?[nodeId];
    if (cached != null) {
      return cached;
    }

    // 2. Try compiled bounds from render document
    final renderDoc = _renderCache[frameId];
    if (renderDoc != null) {
      final renderNode = renderDoc.nodes[nodeId];
      final compiledBounds = renderNode?.compiledBounds;
      if (compiledBounds != null) {
        // Cache compiled bounds for faster subsequent lookups
        _nodeBoundsCache[frameId] ??= {};
        _nodeBoundsCache[frameId]![nodeId] = compiledBounds;
        return compiledBounds;
      }

      // 3. Fall back to explicit bounds from node props (safety measure)
      if (renderNode != null) {
        final bounds = _getNodeBoundsFromProps(renderNode);
        if (bounds != null) {
          _nodeBoundsCache[frameId] ??= {};
          _nodeBoundsCache[frameId]![nodeId] = bounds;
          return bounds;
        }
      }
    }

    // 4. Bounds not yet available
    return null;
  }

  /// Get bounds from node props (only works for absolute-positioned fixed-size nodes).
  Rect? _getNodeBoundsFromProps(RenderNode node) {
    final props = node.props;

    // Must have fixed size
    final sizeMode = props['sizeMode'] as String?;
    if (sizeMode != 'fixed') return null;

    final width = (props['width'] as num?)?.toDouble();
    final height = (props['height'] as num?)?.toDouble();
    if (width == null || height == null) return null;

    // For absolute positioned nodes, use explicit x/y
    final positionMode = props['positionMode'] as String?;
    if (positionMode == 'absolute') {
      final x = (props['x'] as num?)?.toDouble() ?? 0;
      final y = (props['y'] as num?)?.toDouble() ?? 0;
      return Rect.fromLTWH(x, y, width, height);
    }

    // For auto-positioned nodes without cached bounds, we can't determine position
    return null;
  }

  /// Get combined bounds of current selection.
  ///
  /// If [useOriginalBounds] is true, returns the original bounds from the
  /// document (ignoring any drag preview). This is used for snap calculations
  /// where we need the starting position, not the current preview position.
  Rect? _getSelectionBounds({bool useOriginalBounds = false}) {
    Rect? result;
    for (final target in _selection) {
      final bounds = useOriginalBounds
          ? _getOriginalTargetBounds(target)
          : _getTargetBounds(target);
      if (bounds != null) {
        result = result?.expandToInclude(bounds) ?? bounds;
      }
    }
    return result;
  }

  /// Get original bounds for a target (ignoring any drag preview).
  ///
  /// Used for snap calculations where we need the starting position.
  Rect? _getOriginalTargetBounds(DragTarget target) {
    switch (target) {
      case FrameTarget(:final frameId):
        final frame = document.frames[frameId];
        if (frame == null) return null;
        return Rect.fromLTWH(
          frame.canvas.position.dx,
          frame.canvas.position.dy,
          frame.canvas.size.width,
          frame.canvas.size.height,
        );

      case NodeTarget(:final frameId, :final expandedId):
        final frame = document.frames[frameId];
        if (frame == null) return null;

        final localBounds = _getNodeBoundsForFrame(frameId, expandedId);
        if (localBounds == null) return null;

        // Convert to world coordinates using current frame position
        return localBounds.shift(_getFramePosition(frameId));
    }
  }

  /// Get bounds of all frames except those in [exclude].
  Iterable<Rect> _getOtherFrameBounds({required Set<String> exclude}) sync* {
    for (final frame in document.frames.values) {
      if (exclude.contains(frame.id)) continue;
      yield Rect.fromLTWH(
        frame.canvas.position.dx,
        frame.canvas.position.dy,
        frame.canvas.size.width,
        frame.canvas.size.height,
      );
    }
  }
}
